//! Provides a mechanism for updating the player's field of view.

use core::panic;
use std::collections::HashMap;

use common::world::world::{ChunkId, World};

use crate::entity::{EntityId, EntityManager};

type PresenceMap = HashMap<ChunkId, Vec<EntityId>>;

pub struct PresenceSystem {
    pub presence_map: PresenceMap,
}

impl PresenceSystem {
    pub fn new() -> PresenceSystem {
        PresenceSystem {
            presence_map: HashMap::new(),
        }
    }
    // TODO: test it, and think about it, where i can put this function...
    pub fn add_chunks(&mut self, total_chunks: u32) {
        for chunk_id in 0..total_chunks {
            self.presence_map.insert(chunk_id, Vec::new());
        }
    }
    // TODO: actually this function generated by AI, so i dont sure its work good
    pub fn tick(&mut self, entity_manager: &EntityManager, world: &mut World) {
        // self old state
        let mut old_map: PresenceMap = HashMap::new();
        for (chunk_id, entities) in &self.presence_map {
            old_map.insert(*chunk_id, entities.clone());
        }

        // clean
        for entities in self.presence_map.values_mut() {
            entities.clear();
        }

        // add new positions
        for (entity_id, snake) in entity_manager.entities.iter() {
            for body_pos in snake.body.iter() {
                let chunk_id = world.chunk_at(body_pos);

                let was_here = old_map
                    .get(&chunk_id)
                    .map_or(false, |vec| vec.contains(entity_id));

                if !was_here {
                    println!("Entity {} ENTERED chunk {}", entity_id, chunk_id);
                }

                self.add_entity(chunk_id, *entity_id);
            }
        }

        // check if leave
        for (chunk_id, old_entities) in old_map {
            for entity_id in old_entities {
                let still_here = self
                    .presence_map
                    .get(&chunk_id)
                    .map_or(false, |vec| vec.contains(&entity_id));

                if !still_here {
                    println!("Entity {} LEFT chunk {}", entity_id, chunk_id);
                }
            }
        }
    }

    pub fn add_entity(&mut self, chunk_id: ChunkId, entity_id: EntityId) {
        let vec_entity = match self.get_mut(&chunk_id) {
            Some(vec) => vec,
            None => panic!("hello"), // TODO: remove this and make it better
        };

        vec_entity.push(entity_id);
    }

    pub fn remove_entity(&mut self, chunk_id: ChunkId, entity_id: &EntityId) {
        let vec_entity = match self.get_mut(&chunk_id) {
            Some(vec) => vec,
            None => panic!("hello"), // TODO: remove this and make it better
        };

        for (index, value) in vec_entity.iter().enumerate() {
            if value == entity_id {
                vec_entity.swap_remove(index);
                break;
            }
        }
    }

    /// Internal function just wrapper :3
    fn get_mut(&mut self, chunk_id: &ChunkId) -> Option<&mut Vec<EntityId>> {
        self.presence_map.get_mut(chunk_id)
    }

    fn is_in_chunk(&mut self, chunk_id: &ChunkId, entity_id: &EntityId) -> bool {
        true
    }
}
